"use strict";(self.webpackChunktutorial=self.webpackChunktutorial||[]).push([[146],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return u}});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),p=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(a),u=n,h=m["".concat(l,".").concat(u)]||m[u]||d[u]||o;return a?r.createElement(h,i(i({ref:t},c),{},{components:a})):r.createElement(h,i({ref:t},c))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var p=2;p<o;p++)i[p]=a[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},3229:function(e,t,a){a.r(t),a.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return d}});var r=a(7462),n=a(3366),o=(a(7294),a(3905)),i=["components"],s={id:"backend-orientation",title:"Backend Orientation",tags:["prisma","graphql"]},l="Project Orientation",p={unversionedId:"project-setup/backend-orientation",id:"project-setup/backend-orientation",title:"Backend Orientation",description:"Let's take a quick tour through the files included in this project boilerplate. At the root of the repository you have a package.json file containing the dependencies for testing and linting. From there, the code is split into a frontend and a backend directory.",source:"@site/docs/project-setup/backend-orientation.md",sourceDirName:"project-setup",slug:"/project-setup/backend-orientation",permalink:"/full-stack-next-tutorial/docs/project-setup/backend-orientation",editUrl:"https://github.com/lbsonley/full-stack-next-tutorial/docs/project-setup/backend-orientation.md",tags:[{label:"prisma",permalink:"/full-stack-next-tutorial/docs/tags/prisma"},{label:"graphql",permalink:"/full-stack-next-tutorial/docs/tags/graphql"}],version:"current",frontMatter:{id:"backend-orientation",title:"Backend Orientation",tags:["prisma","graphql"]},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/full-stack-next-tutorial/docs/project-setup/getting-started"},next:{title:"Run Local Server and Database",permalink:"/full-stack-next-tutorial/docs/project-setup/run-local-server-database"}},c={},d=[{value:"Backend Organization",id:"backend-organization",level:2},{value:"Prisma Schema",id:"prisma-schema",level:3},{value:"Datasource",id:"datasource",level:4},{value:"Generators",id:"generators",level:4},{value:"Models and Enums",id:"models-and-enums",level:4},{value:"Generate Prisma Assets",id:"generate-prisma-assets",level:3},{value:"Prisma Context",id:"prisma-context",level:3},{value:"GraphQL Schema",id:"graphql-schema",level:3},{value:"Apollo Server",id:"apollo-server",level:3}],m={toc:d};function u(e){var t=e.components,s=(0,n.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},m,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"project-orientation"},"Project Orientation"),(0,o.kt)("p",null,"Let's take a quick tour through the files included in this project boilerplate. At the root of the repository you have a ",(0,o.kt)("inlineCode",{parentName:"p"},"package.json")," file containing the dependencies for testing and linting. From there, the code is split into a ",(0,o.kt)("inlineCode",{parentName:"p"},"frontend")," and a ",(0,o.kt)("inlineCode",{parentName:"p"},"backend")," directory."),(0,o.kt)("h2",{id:"backend-organization"},"Backend Organization"),(0,o.kt)("p",null,"Since this workshop is targeted at Frontend Developers, we will start with a quick overview of the backend code structure, as that will probably require a bit more explanation."),(0,o.kt)("h3",{id:"prisma-schema"},"Prisma Schema"),(0,o.kt)("p",null,"Since Prisma is going to do all of the heavy lifting for us when it comes to making our server and database work, let's start there. All of the Prisma related assets are located in the ",(0,o.kt)("inlineCode",{parentName:"p"},"backend/prisma")," directory. Let' open up ",(0,o.kt)("inlineCode",{parentName:"p"},"prisma/schema.prisma")," and take a look."),(0,o.kt)("p",null,"We'll go through the code blocks one-by-one to get an idea of what each one is doing."),(0,o.kt)("p",null,"For more detailed information, see the ",(0,o.kt)("a",{parentName:"p",href:"https://www.prisma.io/docs/concepts/components/prisma-schema"},"Prisma Schema Docs"),"."),(0,o.kt)("h4",{id:"datasource"},"Datasource"),(0,o.kt)("p",null,"The datasource block is used to give Prisma information about the type of database we are using and where to find that database. We are going to use a Postgres database and that database will be running at the address stored in the ",(0,o.kt)("inlineCode",{parentName:"p"},"DATABASE_URL")," environment variable. We will provide this environment variable via docker-compose for development, and store it in Heroku for production."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:"title=backend/prisma/schema.prisma",title:"backend/prisma/schema.prisma"},'datasource db {\n  provider = "postgresql"\n  url = env("DATABASE_URL")\n  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")\n}\n')),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"NOTE"),": ",(0,o.kt)("inlineCode",{parentName:"em"},"SHADOW_DATABASE_URL")," stores the address of a second database for Prisma to perform migrations. We do not need this variable for local development. But we will need it later when we deploy to Heroku.")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.prisma.io/docs/concepts/components/prisma-schema/data-sources"},"Prisma's Datasource Docs")),(0,o.kt)("h4",{id:"generators"},"Generators"),(0,o.kt)("p",null,"Generator blocks tell prisma which assets it should generate when we run the command ",(0,o.kt)("inlineCode",{parentName:"p"},"prisma generate"),". There can be multiple generator blocks, each one will output different assets."),(0,o.kt)("p",null,"The Prisma Client is the API between the developer and GraphQL. For Prisma to work, we have to generate a Client. The ",(0,o.kt)("inlineCode",{parentName:"p"},"provider")," property defines the language to use when generating the assets. The ",(0,o.kt)("inlineCode",{parentName:"p"},"binaryTargets")," property is to define which operating system is running on the host machine. Prisma keeps ",(0,o.kt)("a",{parentName:"p",href:"https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#binarytargets-options"},"a list of supported operating systems"),"."),(0,o.kt)("p",null,"Since we are building docker based on the alpine linux base image, we going to use the ",(0,o.kt)("inlineCode",{parentName:"p"},'"linux-musl"')," target. Later on when we run ",(0,o.kt)("inlineCode",{parentName:"p"},"prisma generate"),", just ignore the warning about not building for the current operating system. We will only run the server inside of docker or on heroku, so we don't need the Client built for our machine."),(0,o.kt)("p",null,"Once we have our Prisma Client, we are going to add a generator for TypeGraphQL. This generator will automatically generate type-safe CRUD and Relations GraphQL resolvers for us. But there are numerous other generators we could use kept in a ",(0,o.kt)("a",{parentName:"p",href:"https://www.prisma.io/docs/concepts/components/prisma-schema/generators#community-generators"},"list in the Prisma docs"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:"title=backend/prisma/schema.prisma",title:"backend/prisma/schema.prisma"},'generator client {\n  provider = "prisma-client-js"\n  binaryTargets = ["linux-musl"]\n}\n\ngenerator typegraphql {\n  provider = "typegraphql-prisma"\n  output   = "./generated/type-graphql"\n}\n')),(0,o.kt)("p",null,"For general information about configuring Prisma generators, take a look at the ",(0,o.kt)("a",{parentName:"p",href:"https://www.prisma.io/docs/concepts/components/prisma-schema/generators"},"official Prisma generator docs"),". To learn more about our specific generator, check out the ",(0,o.kt)("a",{parentName:"p",href:"https://prisma.typegraphql.com/docs/basics/configuration"},"TypeGraphQL generator docs"),"."),(0,o.kt)("h4",{id:"models-and-enums"},"Models and Enums"),(0,o.kt)("p",null,"After defining the ",(0,o.kt)("inlineCode",{parentName:"p"},"datasource")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"generator")," options for Prisma, we write the actual models for our data. Prisma uses these models to generate tables in the database, and define types for GraphQL."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.prisma.io/docs/concepts/components/prisma-schema/data-model"},"Prisma Models Docs")),(0,o.kt)("h3",{id:"generate-prisma-assets"},"Generate Prisma Assets"),(0,o.kt)("p",null,"Now that we have seen the configuration for Prisma, let's use Prisma to generate the assets needed to run our server. Open up a terminal inside of the ",(0,o.kt)("inlineCode",{parentName:"p"},"backend")," directory and run:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"}," yarn  build\n")),(0,o.kt)("p",null," This command will execute ",(0,o.kt)("inlineCode",{parentName:"p"},"prisma generate"),", which tells Prisma to execute the ",(0,o.kt)("inlineCode",{parentName:"p"},"generator")," blocks that we looked at previously. The first ",(0,o.kt)("inlineCode",{parentName:"p"},"generator")," block will create an importable Prisma Client inside at ",(0,o.kt)("inlineCode",{parentName:"p"},"node_modules/@prisma/client")," which we use to initialize our server. This Client is customized based on the schema we defined in ",(0,o.kt)("inlineCode",{parentName:"p"},"schema.prisma"),"."),(0,o.kt)("p",null,"The second ",(0,o.kt)("inlineCode",{parentName:"p"},"generator")," block will create a large chunk of the GraphQL assets needed for interacting with our server. If you look inside ",(0,o.kt)("inlineCode",{parentName:"p"},"backend/prisma/generated/type-graphql")," you will find the resolvers and type definitions which we will use for generating and querying our GraphQL schema."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"prisma generated assets",src:a(7962).Z,width:"762",height:"1062"})),(0,o.kt)("h3",{id:"prisma-context"},"Prisma Context"),(0,o.kt)("p",null,"We have sucessfully generated our Prisma Client. So how do we use it? Open up the file located ",(0,o.kt)("inlineCode",{parentName:"p"},"prisma/context.ts"),". Here we ",(0,o.kt)("inlineCode",{parentName:"p"},"import  { PrismaClient } from @prisma/client"),". This is the Client we generated in the previous step."),(0,o.kt)("p",null,"The whole initialization logic is a bit complicated to allow for smooth operation during development, but in the middle of all that we instantiate a ",(0,o.kt)("inlineCode",{parentName:"p"},"new PrismaClient()")," and export it."),(0,o.kt)("p",null,"We will use this client, in combination with our GraphQL Schema, to setup our Apollo GraphQL Server."),(0,o.kt)("h3",{id:"graphql-schema"},"GraphQL Schema"),(0,o.kt)("p",null,"Before we get to the code for our server, we have to look at the GraphQL Schema. So, open up ",(0,o.kt)("inlineCode",{parentName:"p"},"backend/src/graphql/schema.ts"),". Inside, you will see that we use the ",(0,o.kt)("inlineCode",{parentName:"p"},"buildSchema")," function from ",(0,o.kt)("inlineCode",{parentName:"p"},"type-graphql")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"resolvers")," generated by Prisma and TypeGraphQL."),(0,o.kt)("p",null,"For more information about the resolvers that are generated, refer to the ",(0,o.kt)("a",{parentName:"p",href:"https://prisma.typegraphql.com/docs/basics/usage#crud-resolvers"},"TypeGraphQL Usage Docs"),"."),(0,o.kt)("p",null,"You don't have to have experience defining GraphQL schemas to see, this is easy."),(0,o.kt)("h3",{id:"apollo-server"},"Apollo Server"),(0,o.kt)("p",null,"Alright, so far we have seen how we define our Prisma Schema, we used Prisma to generate the Client and GraphQL assets, we created an instance of Prisma Client and we defined a GraphQL Schema."),(0,o.kt)("p",null,"Now it's time to see how the Prisma Client and GraphQL schema are used to start our Apollo GraphQL Server. Open up the file at ",(0,o.kt)("inlineCode",{parentName:"p"},"backend/src/app.ts"),"."),(0,o.kt)("p",null,"The code in this file is a slightly modified version of the code found on the ",(0,o.kt)("a",{parentName:"p",href:"https://www.apollographql.com/docs/apollo-server/integrations/middleware/#apollo-server-express"},"Official Apollo Server Docs"),"."),(0,o.kt)("p",null,"Compared with the example code, we omit the ",(0,o.kt)("inlineCode",{parentName:"p"},"typedefs")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"resolvers")," properties, in favor of ",(0,o.kt)("inlineCode",{parentName:"p"},"schema")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"context"),". If you remember from the GraphQL schema file, we passed our ",(0,o.kt)("inlineCode",{parentName:"p"},"resolvers")," (generated by Prisma) there and those resolvers make use of the Prisma Context."),(0,o.kt)("p",null,"For more information, see ",(0,o.kt)("a",{parentName:"p",href:"https://www.apollographql.com/docs/apollo-server/api/apollo-server"},"the docs about configurating Apollo Server"),"."),(0,o.kt)("p",null,"Finally, we import ",(0,o.kt)("inlineCode",{parentName:"p"},"app.ts")," inside of ",(0,o.kt)("inlineCode",{parentName:"p"},"index.ts")," and start our server."))}u.isMDXComponent=!0},7962:function(e,t,a){t.Z=a.p+"assets/images/prisma-generated-10208484d0cf2f9fd291b275221e5277.png"}}]);